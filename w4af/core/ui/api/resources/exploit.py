from flask import jsonify, request

from multiprocessing.dummy import Process

from w4af.core.ui.api import app
from w4af.core.ui.api.utils.error import abort
from w4af.core.ui.api.utils.auth import requires_auth
from w4af.core.ui.api.db.master import SCANS, ScanInfo
from w4af.core.ui.api.utils.log_handler import RESTAPIOutput
from w4af.core.ui.api.utils.scans import (get_scan_info_from_id,
                                          start_scan_helper,
                                          get_new_scan_id,
                                          create_temp_profile,
                                          remove_temp_profile)
from w4af.core.data.parsers.doc.url import URL
from w4af.core.controllers.w4afCore import w4afCore
from w4af.core.controllers.exceptions import BaseFrameworkException

import w4af.core.data.kb.knowledge_base as kb
from w4af.core.controllers.core_helpers.plugins import CorePlugins
from w4af.core.data.misc.encoding import smart_str


@app.route('/scans/<int:scan_id>/kb/<int:vulnerability_id>/exploit/<string:injection>', methods=['GET'])
##@requires_auth
def check_vuln(scan_id, vulnerability_id, injection):
    """
    The whole information related to the specified vulnerability ID

    :param vulnerability_id: The vulnerability ID to query
    :return: All the vulnerability information
    :injection: sqlmap command, like 'tables', 'users', and so on
    """
    scan_info = get_scan_info_from_id(scan_id)
    if scan_info is None:
        abort(404, 'Scan not found')

    for finding_id, finding in enumerate(kb.kb.get_all_findings()):
        if vulnerability_id == finding_id:
            if finding.get_plugin_name() == 'blind_sqli' or finding.get_plugin_name() == 'sqli':
                vuln_to_exploit_id = finding.get_id()
                plugin = scan_info.w4af_core.plugins.get_plugin_inst('attack', 'sqlmap')
                result = plugin.can_exploit(vuln_to_exploit_id)
                exploit_result = plugin.exploit(vuln_to_exploit_id)
                #TODO: exploit non riuscito
                try:
                    shell = exploit_result[0]
                except:
                    return jsonify({'result': 'Exploitation not successfull'})
                tables = shell.generic_user_input(injection, [])
                return jsonify({'result': result})
            else:
                return jsonify({'result': 'Not Exploitable'})

    abort(404, 'Not found')

