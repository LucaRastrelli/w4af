from flask import jsonify, request

from multiprocessing.dummy import Process

from w4af.core.ui.api import app
from w4af.core.ui.api.utils.error import abort
from w4af.core.ui.api.utils.auth import requires_auth
from w4af.core.ui.api.db.master import SCANS, ScanInfo
from w4af.core.ui.api.utils.log_handler import RESTAPIOutput
from w4af.core.ui.api.utils.scans import (get_scan_info_from_id,
                                          start_scan_helper,
                                          get_new_scan_id,
                                          create_temp_profile,
                                          remove_temp_profile)
from w4af.core.data.parsers.doc.url import URL
from w4af.core.controllers.w4afCore import w4afCore
from w4af.core.controllers.exceptions import BaseFrameworkException

import w4af.core.data.kb.knowledge_base as kb
from w4af.core.controllers.core_helpers.plugins import CorePlugins
from w4af.core.data.misc.encoding import smart_str


@app.route('/scans/<int:scan_id>/kb/<int:vulnerability_id>/exploit/<string:injection>', methods=['GET'])
##@requires_auth
def check_vuln(scan_id, vulnerability_id, injection):
    """
    The whole information related to the specified vulnerability ID

    :param vulnerability_id: The vulnerability ID to query
    :return: All the vulnerability information
    """
    scan_info = get_scan_info_from_id(scan_id)
    if scan_info is None:
        abort(404, 'Scan not found')

    for finding_id, finding in enumerate(kb.kb.get_all_findings()):
        if vulnerability_id == finding_id:
            if finding.get_plugin_name() == 'blind_sqli':
                vuln_to_exploit_id = finding.get_id()
                print('vuln_to_exploit_id {}'.format(vuln_to_exploit_id))
                plugin = scan_info.w4af_core.plugins.get_plugin_inst('attack', 'sqlmap')
                result = plugin.can_exploit(vuln_to_exploit_id)
                print('result {}'.format(result))
                exploit_result = plugin.exploit(vuln_to_exploit_id)
                print('exploit_result {}'.format(exploit_result))
                shell = exploit_result[0]
                tables = shell.generic_user_input(injection, [])
                print(tables)
                file = open("/home/rastrelli2/tables.txt", "r")
                print(file.read())
                file.close()
                return jsonify({'result': result})
            else:
                return jsonify({'result': 'Not Exploitable'})

    abort(404, 'Not found')


@app.route('/exploit', methods=['GET'])
# @requires_auth
def test_vuln():
    core = CorePlugins(w4af_core=w4afCore())
    core.init_plugins()
    plugin = core.get_plugin_inst('attack', 'sqlmap')
    return jsonify({'items': True})
